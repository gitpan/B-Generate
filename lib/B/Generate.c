/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Generate.xs. Do not edit this file, edit Generate.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Generate.xs"
#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PERL_OBJECT
#undef PL_op_name
#undef PL_opargs 
#undef PL_op_desc
#define PL_op_name (get_op_names())
#define PL_opargs (get_opargs())
#define PL_op_desc (get_op_descs())
#endif

static char *svclassnames[] = {
    "B::NULL",
    "B::IV",
    "B::NV",
    "B::RV",
    "B::PV",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
    "B::BM",
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
    "B::GV",
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_CVOP,	/* 10 */
    OPc_LOOP,	/* 11 */
    OPc_COP	/* 12 */
} opclass;

static char *opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::CVOP",
    "B::LOOP",
    "B::COP"	
};

static int walkoptree_debug = 0;	/* Flag for walkoptree debug hook */

static SV *specialsv_list[6];

SV** my_current_pad;
SV** tmp_pad;

HV* root_cache;

#define GEN_PAD      { set_active_sub(find_cv_by_root((OP*)o));tmp_pad = PL_curpad;PL_curpad = my_current_pad; }
#define OLD_PAD      (PL_curpad = tmp_pad)
//#define GEN_PAD
//#define OLD_PAD

void
set_active_sub(SV *sv)
{
	AV* padlist; 
	SV** svp;
	//dTHX;
	//	sv_dump(SvRV(sv));
	padlist = CvPADLIST(SvRV(sv));
	if(!padlist) {
		dTHX;
		sv_dump(sv);
		sv_dump((SV*)padlist);
	}
	svp = AvARRAY(padlist);
	my_current_pad = AvARRAY((AV*)svp[1]);
}

static SV *
find_cv_by_root(OP* o) {
  dTHX;
  OP* root = o;
  SV* key;
  SV* val;
  HE* cached;

  if(PL_compcv && SvTYPE(PL_compcv) == SVt_PVCV &&
	!PL_eval_root) {
    //    printf("Compcv\n");
    if(SvROK(PL_compcv))
       sv_dump(SvRV(PL_compcv));
    return newRV((SV*)PL_compcv);
  }	


  if(!root_cache)
    root_cache = newHV();

  while(root->op_next)
    root = root->op_next;

  key = newSViv(PTR2IV(root));
  
  cached = hv_fetch_ent(root_cache, key, 0, 0);
  if(cached) {
    return HeVAL(cached);
  }
  

  if(PL_main_root == root) {
    /* Special case, this is the main root */
    cached = hv_store_ent(root_cache, key, newRV((SV*)PL_main_cv), 0);
  } else if(PL_eval_root == root && PL_compcv) { 
    SV* tmpcv = (SV*)NEWSV(1104,0);
    sv_upgrade((SV *)tmpcv, SVt_PVCV);
    CvPADLIST(tmpcv) = CvPADLIST(PL_compcv);
    SvREFCNT_inc(CvPADLIST(tmpcv));
    CvROOT(tmpcv) = root;
    OP_REFCNT_LOCK;
    OpREFCNT_inc(root);
    OP_REFCNT_UNLOCK;
    cached = hv_store_ent(root_cache, key, newRV((SV*)tmpcv), 0);
  } else {
    /* Need to walk the symbol table, yay */
    CV* cv = 0;
    SV* sva;
    SV* sv;
    register SV* svend;

    for (sva = PL_sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
      svend = &sva[SvREFCNT(sva)];
      for (sv = sva + 1; sv < svend; ++sv) {
	if (SvTYPE(sv) != SVTYPEMASK && SvREFCNT(sv)) {
	  if(SvTYPE(sv) == SVt_PVCV &&
	     CvROOT(sv) == root
	     ) {
	    cv = (CV*) sv;
	  } else if(SvTYPE(sv) == SVt_PVGV && GvGP(sv) &&
		    GvCV(sv) && !CvXSUB(GvCV(sv)) &&
		    CvROOT(GvCV(sv)) == root)
		     {
      	    cv = (CV*) GvCV(sv);
	  }
	}
      }
    }

    if(!cv) {
      Perl_die(aTHX_ "I am sorry but we couldn't find this root!\n");
    }

    cached = hv_store_ent(root_cache, key, newRV((SV*)cv), 0);
  }

  return (SV*) HeVAL(cached);
}


static SV *
make_sv_object(pTHX_ SV *arg, SV *sv)
{
    char *type = 0;
    IV iv;

    for (iv = 0; iv < sizeof(specialsv_list)/sizeof(SV*); iv++) {
    if (sv == specialsv_list[iv]) {
        type = "B::SPECIAL";
        break;
    }
    }
    if (!type) {
    type = svclassnames[SvTYPE(sv)];
    iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}
#define PERL_CUSTOM_OPS
static I32
op_name_to_num(SV * name)
{
    dTHX;
    char *s;
    char *wanted = SvPV_nolen(name);
    int i =0;
    int topop = OP_max;

#ifdef PERL_CUSTOM_OPS
    topop--;
#endif

    if (SvIOK(name) && SvIV(name) >= 0 && SvIV(name) < topop)
        return SvIV(name);

    for (s = PL_op_name[i]; s; s = PL_op_name[++i]) {
        if (strEQ(s, wanted))
            return i;
    }
#ifdef PERL_CUSTOM_OPS
    if (PL_custom_op_names) {
        HE* ent;
        SV* value;
        /* This is sort of a hv_exists, backwards */
        (void)hv_iterinit(PL_custom_op_names);
        while ((ent = hv_iternext(PL_custom_op_names))) {
            if (strEQ(SvPV_nolen(hv_iterval(PL_custom_op_names,ent)),wanted))
                return OP_CUSTOM;
        }
    }
#endif

    croak("No such op \"%s\"", SvPV_nolen(name));

    return -1;
}

#ifdef PERL_CUSTOM_OPS
static void* 
custom_op_ppaddr(char *name)
{
    dTHX;
    HE *ent;
    SV *value;
    if (!PL_custom_op_names)
        return 0;
    
    /* This is sort of a hv_fetch, backwards */
    (void)hv_iterinit(PL_custom_op_names);
    while ((ent = hv_iternext(PL_custom_op_names))) {
        if (strEQ(SvPV_nolen(hv_iterval(PL_custom_op_names,ent)),name))
            return (void*)SvIV(hv_iterkeysv(ent));
    }

    return 0;
}
#endif

static opclass
cc_opclass(pTHX_ OP *o)
{
    if (!o)
	return OPc_NULL;
    //    op_dump(o);
    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV || o->op_type == OP_AELEMFAST)
	return OPc_PADOP;
#endif

    switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP, and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
		? OPc_SVOP : OPc_PVOP;

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 PL_op_name[o->op_type]);
    return OPc_BASEOP;
}

static char *
cc_opclassname(pTHX_ OP *o)
{
    return opclassnames[cc_opclass(aTHX_ o)];
}

static OP * 
SVtoO(SV* sv) {
    dTHX;
    if (SvROK(sv)) {
        IV tmp = SvIV((SV*)SvRV(sv));
        return INT2PTR(OP*,tmp);
    }
    else {
        return 0;
    }
        croak("Argument is not a reference");
    return 0; /* Not reached */
}

/* Pre-5.7 compatibility */
#ifndef op_clear
void op_clear(OP* o) {
    /* Fake it, I'm bored */
    croak("This operation requires a newer version of Perl");
}
#endif
#ifndef op_null
#define op_null    croak("This operation requires a newer version of Perl");
#endif

#ifndef PM_GETRE
#define PM_GETRE(o)     ((o)->op_pmregexp)
#endif

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;

#line 436 "Generate.c"
XS(XS_B_fudge); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_fudge)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: B::fudge()");
    {
#line 442 "Generate.xs"
        SSCHECK(2);
        SSPUSHPTR((SV*)PL_comppad);  
        SSPUSHINT(SAVEt_COMPPAD);
#line 448 "Generate.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_root)
{
    dXSARGS;
    {
	B__OP	RETVAL;
#line 450 "Generate.xs"
        if (items > 0)
            PL_main_root = SVtoO(ST(0));
        RETVAL = PL_main_root;
#line 463 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B_main_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_start)
{
    dXSARGS;
    {
	B__OP	RETVAL;
#line 460 "Generate.xs"
        if (items > 0)
            PL_main_start = SVtoO(ST(0));
        RETVAL = PL_main_start;
#line 481 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define OP_desc(o)	PL_op_desc[o->op_type]
XS(XS_B__OP_find_cv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_find_cv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::find_cv(o)");
    {
	B__OP	o;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 474 "Generate.xs"
	RETVAL = SvRV(find_cv_by_root((OP*)o));
#line 508 "Generate.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_next)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::next(o, ...)");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 482 "Generate.xs"
        if (items > 1)
            o->op_next = SVtoO(ST(1));
        RETVAL = o->op_next;
#line 537 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__OP_sibling); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_sibling)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::sibling(o, ...)");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 492 "Generate.xs"
        if (items > 1)
            o->op_sibling = SVtoO(ST(1));
        RETVAL = o->op_sibling;
#line 565 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__OP_ppaddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_ppaddr)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::ppaddr(o, ...)");
    {
	B__OP	o;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 502 "Generate.xs"
        if (items > 1)
            o->op_ppaddr = (void*)SvIV(ST(1));
	RETVAL = PTR2IV((void*)(o->op_ppaddr));
#line 594 "Generate.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_desc); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_desc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::desc(o)");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_desc(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__OP_targ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_targ)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::targ(o, ...)");
    {
	B__OP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 516 "Generate.xs"
        if (items > 1)
            o->op_targ = (PADOFFSET)SvIV(ST(1));
        RETVAL = o->op_targ;
#line 645 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_type)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::type(o, ...)");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 526 "Generate.xs"
        if (items > 1) {
            o->op_type = (U16)SvIV(ST(1));
            o->op_ppaddr = PL_ppaddr[o->op_type];
        }
        RETVAL = o->op_type;
#line 674 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_seq)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::seq(o, ...)");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 538 "Generate.xs"
        if (items > 1)
            o->op_seq = (U16)SvIV(ST(1));
        RETVAL = o->op_seq;
#line 701 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_flags)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::flags(o, ...)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 548 "Generate.xs"
        if (items > 1)
            o->op_flags = (U8)SvIV(ST(1));
        RETVAL = o->op_flags;
#line 728 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_private); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_private)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::OP::private(o, ...)");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 558 "Generate.xs"
        if (items > 1)
            o->op_private = (U8)SvIV(ST(1));
        RETVAL = o->op_private;
#line 755 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__OP_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_dump)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::dump(o)");
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 568 "Generate.xs"
        op_dump(o);
#line 778 "Generate.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B__OP_clean); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_clean)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::OP::clean(o)");
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 574 "Generate.xs"
        if (o == PL_main_root)
            o->op_next = Nullop;
#line 801 "Generate.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B__OP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_new)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: B::OP::new(class, type, flags)");
    {
	SV *	class = ST(0);
	SV *	type = ST(1);
	I32	flags = (I32)SvIV(ST(2));
	SV**	sparepad;
	OP *	o;
	OP *	saveop;
	I32	typenum;
#line 587 "Generate.xs"
        sparepad = PL_curpad;
        saveop = PL_op;
        PL_curpad = AvARRAY(PL_comppad);
        typenum = op_name_to_num(type);
        o = newOP(typenum, flags);
#ifdef PERL_CUSTOM_OPCODES
        if (typenum == OP_CUSTOM)
            o->op_ppaddr = custom_op_ppaddr(SvPV_nolen(type));
#endif
        PL_curpad = sparepad;
        PL_op = saveop;
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::OP"), PTR2IV(o));
#line 834 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__OP_newstate); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_newstate)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: B::OP::newstate(class, flags, label, oldo)");
    {
	SV *	class = ST(0);
	I32	flags = (I32)SvIV(ST(1));
	char *	label = (char *)SvPV_nolen(ST(2));
	B__OP	oldo;
	SV**	sparepad;
	OP *	o;
	OP *	saveop;

	if (SvROK(ST(3))) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    oldo = INT2PTR(B__OP,tmp);
	}
	else
	    croak("oldo is not a reference");
#line 611 "Generate.xs"
        sparepad = PL_curpad;
        saveop = PL_op;
        PL_curpad = AvARRAY(PL_comppad);
        o = newSTATEOP(flags, label, oldo);
        PL_curpad = sparepad;
        PL_op = saveop;
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::LISTOP"), PTR2IV(o));
#line 869 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__OP_mutate); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_mutate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: B::OP::mutate(o, type)");
    {
	B__OP	o;
	SV*	type = ST(1);
	I32	rtype;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 626 "Generate.xs"
        rtype = op_name_to_num(type);
        o->op_ppaddr = PL_ppaddr[rtype];
        o->op_type = rtype;

#line 897 "Generate.c"
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));

	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__OP_convert); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_convert)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: B::OP::convert(o, type, flags)");
    {
	B__OP	o;
	I32	flags = (I32)SvIV(ST(2));
	I32	type = (I32)SvIV(ST(1));
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 639 "Generate.xs"
        if (!o || o->op_type != OP_LIST)
            o = newLISTOP(OP_LIST, 0, o, Nullop);
        else
            o->op_flags &= ~OPf_WANT;

        if (!(PL_opargs[type] & OA_MARK) && o->op_type != OP_NULL) {
            op_clear(o);
            o->op_targ = o->op_type;
        }

        o->op_type = type;
        o->op_ppaddr = PL_ppaddr[type];
        o->op_flags |= flags;

        o = CALL_FPTR(PL_check[type])(aTHX_ (OP*)o);

        if (o->op_type == type)
            o = fold_constants(o);

#line 943 "Generate.c"
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));

	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__UNOP_first); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__UNOP_first)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::UNOP::first(o, ...)");
    {
	B__UNOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__UNOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 667 "Generate.xs"
        if (items > 1)
            o->op_first = SVtoO(ST(1));
        RETVAL = o->op_first;
#line 971 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__UNOP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__UNOP_new)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: B::UNOP::new(class, type, flags, sv_first)");
    {
	SV *	class = ST(0);
	SV *	type = ST(1);
	I32	flags = (I32)SvIV(ST(2));
	SV *	sv_first = ST(3);
	OP *	first;
	OP *	o;
	I32	typenum;
#line 683 "Generate.xs"
        if (SvROK(sv_first)) {
            if (!sv_derived_from(sv_first, "B::OP"))
                Perl_croak(aTHX_ "Reference 'first' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_first));
                first = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_first))
            Perl_croak(aTHX_ 
            "'first' argument to B::UNOP->new should be a B::OP object or a false value");
        else
            first = Nullop;
        {
        I32 padflag = 0;
        SV**sparepad = PL_curpad;
        OP* saveop = PL_op; 

        PL_curpad = AvARRAY(PL_comppad);
        typenum = op_name_to_num(type);
        o = newUNOP(typenum, flags, first);
#ifdef PERL_CUSTOM_OPCODES
        if (typenum == OP_CUSTOM)
            o->op_ppaddr = custom_op_ppaddr(SvPV_nolen(type));
#endif
        PL_curpad = sparepad;
        PL_op = saveop;
        }
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::UNOP"), PTR2IV(o));
#line 1023 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__BINOP_null); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_null)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::BINOP::null(o)");
    {
	B__BINOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__BINOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 719 "Generate.xs"
		op_null((OP*)o);
#line 1045 "Generate.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_B__BINOP_last); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_last)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::BINOP::last(o, ...)");
    {
	B__BINOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__BINOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 725 "Generate.xs"
        if (items > 1)
            o->op_last = SVtoO(ST(1));
        RETVAL = o->op_last;
#line 1070 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__BINOP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_new)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: B::BINOP::new(class, type, flags, sv_first, sv_last)");
    {
	SV *	class = ST(0);
	SV *	type = ST(1);
	I32	flags = (I32)SvIV(ST(2));
	SV *	sv_first = ST(3);
	SV *	sv_last = ST(4);
	OP *	first;
	OP *	last;
	OP *	o;
#line 742 "Generate.xs"
        if (SvROK(sv_first)) {
            if (!sv_derived_from(sv_first, "B::OP"))
                Perl_croak(aTHX_ "Reference 'first' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_first));
                first = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_first))
            Perl_croak(aTHX_ 
            "'first' argument to B::UNOP->new should be a B::OP object or a false value");
        else
            first = Nullop;

        if (SvROK(sv_last)) {
            if (!sv_derived_from(sv_last, "B::OP"))
                Perl_croak(aTHX_ "Reference 'last' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_last));
                last = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_last))
            Perl_croak(aTHX_ 
            "'last' argument to B::BINOP->new should be a B::OP object or a false value");
        else
            last = Nullop;

        {
        SV**sparepad = PL_curpad;
        OP* saveop = PL_op;
        I32 optype = op_name_to_num(type);

        PL_curpad = AvARRAY(PL_comppad);

        if (optype == OP_SASSIGN || optype == OP_AASSIGN) 
            o = newASSIGNOP(flags, first, 0, last);
        else {
            o = newBINOP(optype, flags, first, last);
#ifdef PERL_CUSTOM_OPCODES
            if (typenum == OP_CUSTOM)
                o->op_ppaddr = custom_op_ppaddr(SvPV_nolen(type));
#endif
        }

        PL_curpad = sparepad;
        PL_op = saveop;
        }
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::BINOP"), PTR2IV(o));
#line 1142 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__LISTOP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LISTOP_new)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: B::LISTOP::new(class, type, flags, sv_first, sv_last)");
    {
	SV *	class = ST(0);
	SV *	type = ST(1);
	I32	flags = (I32)SvIV(ST(2));
	SV *	sv_first = ST(3);
	SV *	sv_last = ST(4);
	OP *	first;
	OP *	last;
	OP *	o;
#line 804 "Generate.xs"
        if (SvROK(sv_first)) {
            if (!sv_derived_from(sv_first, "B::OP"))
                Perl_croak(aTHX_ "Reference 'first' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_first));
                first = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_first))
            Perl_croak(aTHX_ 
            "'first' argument to B::UNOP->new should be a B::OP object or a false value");
        else
            first = Nullop;

        if (SvROK(sv_last)) {
            if (!sv_derived_from(sv_last, "B::OP"))
                Perl_croak(aTHX_ "Reference 'last' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_last));
                last = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_last))
            Perl_croak(aTHX_ 
            "'last' argument to B::BINOP->new should be a B::OP object or a false value");
        else
            last = Nullop;

        {
        SV**sparepad = PL_curpad;
        OP* saveop   = PL_op;
        I32 typenum = op_name_to_num(type);

        PL_curpad = AvARRAY(PL_comppad);
        o = newLISTOP(typenum, flags, first, last);
#ifdef PERL_CUSTOM_OPCODES
        if (typenum == OP_CUSTOM)
            o->op_ppaddr = custom_op_ppaddr(SvPV_nolen(type));
#endif
        PL_curpad = sparepad;
        PL_op = saveop;
        }
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::LISTOP"), PTR2IV(o));
#line 1205 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__LOGOP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_new)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: B::LOGOP::new(class, type, flags, sv_first, sv_last)");
    {
	SV *	class = ST(0);
	SV *	type = ST(1);
	I32	flags = (I32)SvIV(ST(2));
	SV *	sv_first = ST(3);
	SV *	sv_last = ST(4);
	OP *	first;
	OP *	last;
	OP *	o;
#line 860 "Generate.xs"
        if (SvROK(sv_first)) {
            if (!sv_derived_from(sv_first, "B::OP"))
                Perl_croak(aTHX_ "Reference 'first' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_first));
                first = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_first))
            Perl_croak(aTHX_ 
            "'first' argument to B::UNOP->new should be a B::OP object or a false value");
        else
            first = Nullop;

        if (SvROK(sv_last)) {
            if (!sv_derived_from(sv_last, "B::OP"))
                Perl_croak(aTHX_ "Reference 'last' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_last));
                last = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_last))
            Perl_croak(aTHX_ 
            "'last' argument to B::BINOP->new should be a B::OP object or a false value");
        else
            last = Nullop;

        {
        SV**sparepad = PL_curpad;
        OP* saveop   = PL_op;
        I32 typenum  = op_name_to_num(type);
        PL_curpad = AvARRAY(PL_comppad);
        o = newLOGOP(typenum, flags, first, last);
#ifdef PERL_CUSTOM_OPCODES
        if (typenum == OP_CUSTOM)
            o->op_ppaddr = custom_op_ppaddr(SvPV_nolen(type));
#endif
        PL_curpad = sparepad;
        PL_op = saveop;
        }
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::LOGOP"), PTR2IV(o));
#line 1267 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__LOGOP_newcond); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_newcond)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: B::LOGOP::newcond(class, flags, sv_first, sv_last, sv_else)");
    {
	SV *	class = ST(0);
	I32	flags = (I32)SvIV(ST(1));
	SV *	sv_first = ST(2);
	SV *	sv_last = ST(3);
	SV *	sv_else = ST(4);
	OP *	first;
	OP *	last;
	OP *	elseo;
	OP *	o;
#line 914 "Generate.xs"
        if (SvROK(sv_first)) {
            if (!sv_derived_from(sv_first, "B::OP"))
                Perl_croak(aTHX_ "Reference 'first' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_first));
                first = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_first))
            Perl_croak(aTHX_ 
            "'first' argument to B::UNOP->new should be a B::OP object or a false value");
        else
            first = Nullop;

        if (SvROK(sv_last)) {
            if (!sv_derived_from(sv_last, "B::OP"))
                Perl_croak(aTHX_ "Reference 'last' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_last));
                last = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_last))
            Perl_croak(aTHX_ 
            "'last' argument to B::BINOP->new should be a B::OP object or a false value");
        else
            last = Nullop;

        if (SvROK(sv_else)) {
            if (!sv_derived_from(sv_else, "B::OP"))
                Perl_croak(aTHX_ "Reference 'else' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_else));
                elseo = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_else))
            Perl_croak(aTHX_ 
            "'last' argument to B::BINOP->new should be a B::OP object or a false value");
        else
            elseo = Nullop;

        {
        SV**sparepad = PL_curpad;
        OP* saveop   = PL_op;
        PL_curpad = AvARRAY(PL_comppad);
        o = newCONDOP(flags, first, last, elseo);
        PL_curpad = sparepad;
        PL_op = saveop;
        }
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::LOGOP"), PTR2IV(o));
#line 1338 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__LOGOP_other); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_other)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::LOGOP::other(o, ...)");
    {
	B__LOGOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOGOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 968 "Generate.xs"
        if (items > 1)
            o->op_other = SVtoO(ST(1));
        RETVAL = o->op_other;
#line 1363 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define PMOP_pmreplroot(o)	o->op_pmreplroot
#define PMOP_pmnext(o)		o->op_pmnext
#define PMOP_pmregexp(o)	o->op_pmregexp
#define PMOP_pmflags(o)		o->op_pmflags
#define PMOP_pmpermflags(o)	o->op_pmpermflags
XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmreplroot(o)");
    {
	B__PMOP	o;
	OP *	root;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 987 "Generate.xs"
	ST(0) = sv_newmortal();
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     PTR2IV(root));
	}
	else {
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)), PTR2IV(root));
	}
#line 1404 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmreplstart); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplstart)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmreplstart(o, ...)");
    {
	B__PMOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1003 "Generate.xs"
        if (items > 1)
            o->op_pmreplstart = SVtoO(ST(1));
        RETVAL = o->op_pmreplstart;
#line 1429 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmnext); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmnext)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmnext(o, ...)");
    {
	B__PMOP	o;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1013 "Generate.xs"
        if (items > 1)
            o->op_pmnext = (PMOP*)SVtoO(ST(1));
        RETVAL = o->op_pmnext;
#line 1457 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmflags)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmflags(o)");
    {
	B__PMOP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_pmpermflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmpermflags)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::pmpermflags(o)");
    {
	B__PMOP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmpermflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PMOP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_precomp)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PMOP::precomp(o)");
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1032 "Generate.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setpvn(ST(0), rx->precomp, rx->prelen);
#line 1534 "Generate.c"
    }
    XSRETURN(1);
}

#define SVOP_sv(o)     (cSVOPo_sv)
#define SVOP_gv(o)     ((GV*)cSVOPo_sv)
XS(XS_B__SVOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_sv)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::SVOP::sv(o, ...)");
    {
	B__SVOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1046 "Generate.xs"
        GEN_PAD;
        if (items > 1)
            cSVOPo_sv = newSVsv(ST(1));
        RETVAL = cSVOPo_sv;
        OLD_PAD;
#line 1563 "Generate.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__SVOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_gv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SVOP::gv(o)");
    {
	B__SVOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__SVOP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_new)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: B::SVOP::new(class, type, flags, sv)");
    {
	SV *	class = ST(0);
	SV *	type = ST(1);
	I32	flags = (I32)SvIV(ST(2));
	SV *	sv = ST(3);
	SV**	sparepad;
	OP *	o;
	OP *	saveop;
	SV*	param;
	I32	typenum;
#line 1070 "Generate.xs"
	sparepad = PL_curpad;
        PL_curpad = AvARRAY(PL_comppad);
        saveop = PL_op;
        typenum = op_name_to_num(type); /* XXX More classes here! */
        if (typenum == OP_GVSV) {
            if (*(SvPV_nolen(sv)) == '$') 
                param = (SV*)gv_fetchpv(SvPVX(sv)+1, TRUE, SVt_PV);
            else
            Perl_croak(aTHX_ 
            "First character to GVSV was not dollar");
        } else
            param = newSVsv(sv);
        o = newSVOP(typenum, flags, param);
#ifdef PERL_CUSTOM_OPCODES
        if (typenum == OP_CUSTOM)
            o->op_ppaddr = custom_op_ppaddr(SvPV_nolen(type));
#endif
	    //PL_curpad = sparepad;
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::SVOP"), PTR2IV(o));
        PL_op = saveop;
#line 1636 "Generate.c"
    }
    XSRETURN(1);
}

#define PADOP_padix(o)	o->op_padix
#define PADOP_sv(o)	(o->op_padix ? PL_curpad[o->op_padix] : Nullsv)
#define PADOP_gv(o)	((o->op_padix \
			  && SvTYPE(PL_curpad[o->op_padix]) == SVt_PVGV) \
			 ? (GV*)PL_curpad[o->op_padix] : Nullgv)
XS(XS_B__PADOP_padix); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_padix)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::PADOP::padix(o, ...)");
    {
	B__PADOP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1104 "Generate.xs"
        if (items > 1)
            o->op_padix = (PADOFFSET)SvIV(ST(1));
        RETVAL = o->op_padix;
#line 1667 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__PADOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_sv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PADOP::sv(o)");
    {
	B__PADOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PADOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_gv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PADOP::gv(o)");
    {
	B__PADOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PVOP_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVOP_pv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::PVOP::pv(o)");
    {
	B__PVOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PVOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1124 "Generate.xs"
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	ST(0) = sv_2mortal(newSVpv(o->op_pv, (o->op_type == OP_TRANS) ?
				   256 * sizeof(short) : 0));
#line 1747 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__LOOP_redoop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_redoop)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::LOOP::redoop(o, ...)");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1137 "Generate.xs"
        if (items > 1)
            o->op_redoop = SVtoO(ST(1));
        RETVAL = o->op_redoop;
#line 1772 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__LOOP_nextop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_nextop)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::LOOP::nextop(o, ...)");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1147 "Generate.xs"
        if (items > 1)
            o->op_nextop = SVtoO(ST(1));
        RETVAL = o->op_nextop;
#line 1800 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__LOOP_lastop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_lastop)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::LOOP::lastop(o, ...)");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1157 "Generate.xs"
        if (items > 1)
            o->op_lastop = SVtoO(ST(1));
        RETVAL = o->op_lastop;
#line 1828 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define COP_label(o)	o->cop_label
#define COP_stashpv(o)	CopSTASHPV(o)
#define COP_stash(o)	CopSTASH(o)
#define COP_file(o)	CopFILE(o)
#define COP_cop_seq(o)	o->cop_seq
#define COP_arybase(o)	o->cop_arybase
#define COP_line(o)	CopLINE(o)
#define COP_warnings(o)	o->cop_warnings
XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::label(o)");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__COP_stashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stashpv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::stashpv(o)");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__COP_stash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stash)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::stash(o)");
    {
	B__COP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__COP_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_file)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::file(o)");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_file(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_B__COP_cop_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_cop_seq)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::cop_seq(o)");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_cop_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__COP_arybase); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_arybase)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::arybase(o)");
    {
	B__COP	o;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_arybase(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__COP_line); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_line)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::line(o)");
    {
	B__COP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_line(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::COP::warnings(o)");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_warnings(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__COP_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_new)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: B::COP::new(class, flags, name, sv_first)");
    {
	SV *	class = ST(0);
	char *	name = (char *)SvPV_nolen(ST(2));
	I32	flags = (I32)SvIV(ST(1));
	SV *	sv_first = ST(3);
	OP *	first;
	OP *	o;
	B__COP	RETVAL;
#line 1216 "Generate.xs"
        if (SvROK(sv_first)) {
            if (!sv_derived_from(sv_first, "B::OP"))
                Perl_croak(aTHX_ "Reference 'first' was not a B::OP object");
            else {
                IV tmp = SvIV((SV*)SvRV(sv_first));
                first = INT2PTR(OP*, tmp);
            }
        } else if (SvTRUE(sv_first))
            Perl_croak(aTHX_ 
            "'first' argument to B::COP->new should be a B::OP object or a false value");
        else
            first = Nullop;

        {
        SV**sparepad = PL_curpad;
        OP* saveop = PL_op;
        PL_curpad = AvARRAY(PL_comppad);
        o = newSTATEOP(flags, name, first);
        PL_curpad = sparepad;
        PL_op = saveop;
        }
	    ST(0) = sv_newmortal();
        sv_setiv(newSVrv(ST(0), "B::COP"), PTR2IV(o));
#line 2078 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__SV_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_sv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::sv(sv)");
    {
	B__SV	sv;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1246 "Generate.xs"
        RETVAL = newSVsv(sv);
#line 2101 "Generate.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_B__SV_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_dump)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::SV::dump(sv)");
    {
	B__SV	sv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1254 "Generate.xs"
        sv_dump(sv);
#line 2127 "Generate.c"
    }
    XSRETURN(1);
}

XS(XS_B__SV_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_FLAGS)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::SV::FLAGS(sv, ...)");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1260 "Generate.xs"
        if (items > 1)
            sv->sv_flags = SvIV(ST(1));
        RETVAL = SvFLAGS(sv);
#line 2153 "Generate.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_B__CV_ROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_ROOT)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: B::CV::ROOT(cv)");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1272 "Generate.xs"
	if(cv == PL_main_cv) {
	RETVAL = PL_main_root;
	} else {
	RETVAL = CvROOT(cv);
	}
#line 2181 "Generate.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

XS(XS_B__CV_newsub_simple); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_newsub_simple)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: B::CV::newsub_simple(class, name, block)");
    {
	SV*	class = ST(0);
	SV*	name = ST(1);
	B__OP	block;
	CV*	mycv;
	OP*	o;
	B__CV	RETVAL;

	if (SvROK(ST(2))) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    block = INT2PTR(B__OP,tmp);
	}
	else
	    croak("block is not a reference");
#line 1289 "Generate.xs"
        o = newSVOP(OP_CONST, 0, name);
        mycv = newSUB(start_subparse(FALSE, 0), o, Nullop, block);
        /*op_free(o); */
        RETVAL = mycv;
#line 2214 "Generate.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

XS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PV)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: B::PV::PV(sv, ...)");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1303 "Generate.xs"
{
  if(items > 1) {
    sv_setpv(sv, SvPV_nolen(ST(1)));    
  } 
  ST(0) = sv_newmortal();
  if( SvPOK(sv) ) { 
    sv_setpvn(ST(0), SvPVX(sv), SvCUR(sv));
    SvFLAGS(ST(0)) |= SvUTF8(sv);
  }
  else {
    /* XXX for backward compatibility, but should fail */
    /* croak( "argument is not SvPOK" ); */
    sv_setpvn(ST(0), NULL, 0);
  }
}
#line 2254 "Generate.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_B__Generate); /* prototype to pass -Wmissing-prototypes */
XS(boot_B__Generate)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("B::fudge", XS_B_fudge, file);
        newXSproto("B::main_root", XS_B_main_root, file, ";$");
        newXSproto("B::main_start", XS_B_main_start, file, ";$");
        newXS("B::OP::find_cv", XS_B__OP_find_cv, file);
        newXS("B::OP::next", XS_B__OP_next, file);
        newXS("B::OP::sibling", XS_B__OP_sibling, file);
        newXS("B::OP::ppaddr", XS_B__OP_ppaddr, file);
        newXS("B::OP::desc", XS_B__OP_desc, file);
        newXS("B::OP::targ", XS_B__OP_targ, file);
        newXS("B::OP::type", XS_B__OP_type, file);
        newXS("B::OP::seq", XS_B__OP_seq, file);
        newXS("B::OP::flags", XS_B__OP_flags, file);
        newXS("B::OP::private", XS_B__OP_private, file);
        newXS("B::OP::dump", XS_B__OP_dump, file);
        newXS("B::OP::clean", XS_B__OP_clean, file);
        newXS("B::OP::new", XS_B__OP_new, file);
        newXS("B::OP::newstate", XS_B__OP_newstate, file);
        newXS("B::OP::mutate", XS_B__OP_mutate, file);
        newXS("B::OP::convert", XS_B__OP_convert, file);
        newXS("B::UNOP::first", XS_B__UNOP_first, file);
        newXS("B::UNOP::new", XS_B__UNOP_new, file);
        newXS("B::BINOP::null", XS_B__BINOP_null, file);
        newXS("B::BINOP::last", XS_B__BINOP_last, file);
        newXS("B::BINOP::new", XS_B__BINOP_new, file);
        newXS("B::LISTOP::new", XS_B__LISTOP_new, file);
        newXS("B::LOGOP::new", XS_B__LOGOP_new, file);
        newXS("B::LOGOP::newcond", XS_B__LOGOP_newcond, file);
        newXS("B::LOGOP::other", XS_B__LOGOP_other, file);
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
        newXS("B::PMOP::pmreplstart", XS_B__PMOP_pmreplstart, file);
        newXS("B::PMOP::pmnext", XS_B__PMOP_pmnext, file);
        newXS("B::PMOP::pmflags", XS_B__PMOP_pmflags, file);
        newXS("B::PMOP::pmpermflags", XS_B__PMOP_pmpermflags, file);
        newXS("B::PMOP::precomp", XS_B__PMOP_precomp, file);
        newXS("B::SVOP::sv", XS_B__SVOP_sv, file);
        newXS("B::SVOP::gv", XS_B__SVOP_gv, file);
        newXS("B::SVOP::new", XS_B__SVOP_new, file);
        newXS("B::PADOP::padix", XS_B__PADOP_padix, file);
        newXS("B::PADOP::sv", XS_B__PADOP_sv, file);
        newXS("B::PADOP::gv", XS_B__PADOP_gv, file);
        newXS("B::PVOP::pv", XS_B__PVOP_pv, file);
        newXS("B::LOOP::redoop", XS_B__LOOP_redoop, file);
        newXS("B::LOOP::nextop", XS_B__LOOP_nextop, file);
        newXS("B::LOOP::lastop", XS_B__LOOP_lastop, file);
        newXS("B::COP::label", XS_B__COP_label, file);
        newXS("B::COP::stashpv", XS_B__COP_stashpv, file);
        newXS("B::COP::stash", XS_B__COP_stash, file);
        newXS("B::COP::file", XS_B__COP_file, file);
        newXS("B::COP::cop_seq", XS_B__COP_cop_seq, file);
        newXS("B::COP::arybase", XS_B__COP_arybase, file);
        newXS("B::COP::line", XS_B__COP_line, file);
        newXS("B::COP::warnings", XS_B__COP_warnings, file);
        newXS("B::COP::new", XS_B__COP_new, file);
        newXS("B::SV::sv", XS_B__SV_sv, file);
        newXS("B::SV::dump", XS_B__SV_dump, file);
        newXS("B::SV::FLAGS", XS_B__SV_FLAGS, file);
        newXS("B::CV::ROOT", XS_B__CV_ROOT, file);
        newXS("B::CV::newsub_simple", XS_B__CV_newsub_simple, file);
        newXS("B::PV::PV", XS_B__PV_PV, file);

    /* Initialisation Section */

#line 429 "Generate.xs"
{
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = pWARN_ALL;
    specialsv_list[5] = pWARN_NONE;
    specialsv_list[6] = pWARN_STD;
}

#line 2343 "Generate.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

